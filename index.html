<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mini Dino (Easy Mode)</title>
<style>
  html,body { margin:0; padding:0; background:#fff; }
  canvas { display:block; margin:auto; background:#fff; image-rendering: pixelated; cursor:pointer; }
</style>
</head>
<body>
<canvas id="game" width="400" height="150"></canvas>
<script>
const W = 400, H = 150;
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let state = 'idle'; // 'idle' | 'running' | 'dead'
let t = 0, speed = 3.5, groundX = 0, score = 0, hiScore = 0;
let obstacles = [], clouds = [];
let dino, jumpHold = false, jumpTime = 0;

function rnd(a,b){ return Math.random()*(b-a)+a; }
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

// Colors
const COL = {
  ink: '#535353',
  ground: '#8b8b8b',
  sky: '#cfcfcf'
};

// Dino frames
const DINO = { w: 44, h: 48, ox: 10, oy: 10, frames: [] };
(function buildDino(){
  const cw = 60, ch = 60;
  function frame(runPhase=0){
    const off = document.createElement('canvas');
    off.width = cw; off.height = ch;
    const c = off.getContext('2d');
    c.fillStyle = COL.ink;
    // body
    c.fillRect(18,18, 22,20);
    c.fillRect(34,14, 10,10);
    c.fillRect(40,10, 4,4);
    c.fillRect(43,13, 2,2);
    // legs
    if(runPhase===0){
      c.fillRect(22,38, 6,10);
      c.fillRect(32,40, 6,8);
    } else {
      c.fillRect(22,40, 6,8);
      c.fillRect(32,38, 6,10);
    }
    return off;
  }
  DINO.frames.push(frame(0), frame(1), frame(0));
})();

// Cactus
const CACT = [];
(function buildCactuses(){
  function cactusSmall(){
    const off = document.createElement('canvas');
    off.width = 24; off.height = 40;
    const c = off.getContext('2d'); c.fillStyle = COL.ink;
    c.fillRect(10,10, 6,26);
    c.fillRect(5,18, 5,6);
    c.fillRect(16,22, 5,6);
    return off;
  }
  CACT.push(cactusSmall());
})();

// Cloud
const CLOUD = (() => {
  const off = document.createElement('canvas');
  off.width = 50; off.height = 20;
  const c = off.getContext('2d'); c.fillStyle = COL.sky;
  c.fillRect(6,8, 12,6);
  c.fillRect(12,6, 20,8);
  c.fillRect(26,8, 16,6);
  return off;
})();

function reset(){
  state = 'idle';
  speed = 3.5;
  groundX = 0;
  score = 0;
  obstacles = [];
  clouds = [];
  dino = {
    x: 30,
    y: groundY() - DINO.h,
    vy: 0,
    onGround: true,
    anim: 0
  };
  for(let i=0;i<3;i++){
    clouds.push({ x: rnd(0,W), y: rnd(10,40), v: rnd(0.3,0.8) });
  }
}
function groundY(){ return 130; }

function spawnObstacle(){
  const img = CACT[0];
  let x = W + rnd(0, 80);
  // Easier gap settings
  const minGap = clamp(140 - speed*4, 100, 160);
  if(obstacles.length){
    x = Math.max(x, obstacles[obstacles.length-1].x + minGap + rnd(40, 80));
  }
  obstacles.push({ img, w: img.width, h: img.height, x, y: groundY() - img.height });
}

function spawnCloud(){
  clouds.push({ x: W + rnd(0,50), y: rnd(10,45), v: rnd(0.3,0.8) });
}

function update(dt){
  if(state!=='running') return;
  speed += 0.0005 * dt;

  groundX -= speed;
  if(groundX < -40) groundX += 40;

  for(const c of clouds){ c.x -= c.v; }
  clouds = clouds.filter(c => c.x > -60);
  if(Math.random() < 0.008) spawnCloud();

  for(const o of obstacles){ o.x -= speed; }
  obstacles = obstacles.filter(o => o.x + o.w > -4);
  if(obstacles.length===0 || (W - (obstacles[obstacles.length-1]?.x||0)) > 140+rnd(40,80)){
    spawnObstacle();
  }

  // Jump physics
  if(jumpHold && !dino.onGround && jumpTime < 12){
    dino.vy -= 0.25; // extend jump if holding
    jumpTime++;
  }

  dino.vy += 0.4; // gravity
  dino.y += dino.vy;
  const gy = groundY() - DINO.h;
  if(dino.y >= gy){
    dino.y = gy; dino.vy = 0; dino.onGround = true;
  }

  dino.anim += speed*0.12;

  score += Math.floor(dt*0.05);
  if(score>hiScore) hiScore = score;

  for(const o of obstacles){
    const a = {x:dino.x+6, y:dino.y+6, w:DINO.w-12, h:DINO.h-8};
    const b = {x:o.x+2, y:o.y+2, w:o.w-4, h:o.h-4};
    if(a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y){
      state = 'dead';
      break;
    }
  }
}

function startJump(){
  if(state==='idle'){
    state='running';
  }
  if(state==='running' && dino.onGround){
    dino.vy = -6; // lower jump height base
    dino.onGround = false;
    jumpTime = 0;
  }
}

function draw(){
  ctx.clearRect(0,0,W,H);
  for(const c of clouds) ctx.drawImage(CLOUD, Math.round(c.x), Math.round(c.y));

  ctx.strokeStyle = COL.ground;
  ctx.beginPath();
  ctx.moveTo(0, groundY()+0.5);
  ctx.lineTo(W, groundY()+0.5);
  ctx.stroke();

  for(let x = Math.floor(groundX)%40; x < W; x+=40){
    ctx.fillStyle = COL.ground;
    ctx.fillRect(x+8, groundY()+3, 2,1);
  }

  for(const o of obstacles) ctx.drawImage(o.img, Math.round(o.x), Math.round(o.y));

  let frame = (state==='running' && dino.onGround) ? Math.floor(dino.anim)%2 : 2;
  ctx.drawImage(DINO.frames[frame], Math.round(dino.x - DINO.ox), Math.round(dino.y - DINO.oy));

  drawScore();
  if(state==='idle'){
    drawCenterText('Press Space/↑/Click to Start');
  } else if(state==='dead'){
    drawCenterText('GAME OVER - Press Space/↑/Click');
  }
}

function drawScore(){
  const s = String(score).padStart(5,'0');
  const hs = String(hiScore).padStart(5,'0');
  ctx.fillStyle = '#666';
  ctx.font = '10px monospace';
  ctx.fillText('HI ' + hs + '  ' + s, W-110, 6);
}

function drawCenterText(msg){
  ctx.fillStyle = '#444';
  ctx.font = '12px monospace';
  const m = ctx.measureText(msg);
  ctx.fillText(msg, Math.round((W - m.width)/2), 70);
}

function preventScrollKeys(e){
  if (['Space','ArrowUp','ArrowDown'].includes(e.code)){
    e.preventDefault();
  }
}
document.addEventListener('keydown', preventScrollKeys, {passive:false});

document.addEventListener('keydown', e=>{
  if(['Space','ArrowUp'].includes(e.code)){
    if(state==='dead'){ reset(); state='running'; }
    jumpHold = true;
    startJump();
  }
});
document.addEventListener('keyup', e=>{
  if(['Space','ArrowUp'].includes(e.code)){
    jumpHold = false;
  }
});

canvas.addEventListener('click', ()=>{
  if(state==='dead'){ reset(); state='running'; }
  else { startJump(); jumpHold = true; setTimeout(()=>jumpHold=false, 100); }
});

canvas.addEventListener('touchstart', e=>{
  e.preventDefault();
  if(state==='dead'){ reset(); state='running'; }
  else { startJump(); jumpHold = true; }
}, {passive:false});
canvas.addEventListener('touchend', e=>{ jumpHold = false; });

let last = performance.now();
function tick(now){
  const dt = now - last; last = now;
  t += dt;
  update(dt);
  draw();
  requestAnimationFrame(tick);
}
reset();
requestAnimationFrame(tick);
</script>
</body>
</html>
